
## std::crypto::dsa::falcon
| Procedure | Description |
| ----------- | ------------- |
| normalize_poly512 | Given a degree 512 polynomial on stack, using its starting (absolute) memory address,<br /><br />this routine normalizes each coefficient of the polynomial, using above defined<br /><br />`normalize()` routine<br /><br />Imagine, f is the given polynomial of degree 512. It can be normalized using<br /><br />g = [normalize(f[i]) for i in range(512)]<br /><br />Expected stack state :<br /><br />[f_start_addr, g_start_addr, ...] \| next 127 absolute addresses can be computed using `INCR` instruction<br /><br />Post normalization stack state looks like<br /><br />[ ... ]<br /><br />Note, input polynomial which is provided using memory addresses, is not mutated. |
| squared_norm_poly512 | Given a degree 512 polynomial in coefficient form, as starting (absolute) memory address<br /><br />on stack, this routine computes squared norm of that vector, using following formula<br /><br />Say, f = [a0, a1, a2, ..., a510, a511]<br /><br />g = sq_norm(f) = a0 ^ 2 + a1 ^ 2 + ... + a510 ^ 2 + a511 ^ 2<br /><br />Expected input stack state :<br /><br />[f_start_addr, ...] \| f_addr`i` holds f[(i << 2) .. ((i+1) << 2)]<br /><br />Consecutive 127 addresses on stack can be computed using `INCR` instruction, because memory<br /><br />addresses are consecutive i.e. monotonically increasing by 1.<br /><br />Final stack state :<br /><br />[g, ...] \| g = sq_norm(f) |
| verify | Falcon-512 Digital Signature Verification routine<br /><br />Given four degree-511 polynomials, using initial absolute memory addresses on stack,<br /><br />this routine checks whether it's a valid Falcon signature or not.<br /><br />Four degree-511 polynomials, which are provided ( in order )<br /><br />f = [f0, f1, ..., f510, f511] -> decompressed Falcon-512 signature<br /><br />g = [g0, g1, ..., g510, g511] -> public key used for signing input message<br /><br />h = [h0, h1, ..., h510, h511] -> input message hashed using SHAKE256 XOF and converted to polynomial<br /><br />k = [k0, k1, ..., k510, k511] -> [abs(i) for i in f] \| abs(a) = a < 0 ? 0 - a : a<br /><br />Each of these polynomials are represented using starting absolute memory address. Contiguous 127<br /><br />memory addresses can be computed by repeated application of INCR instruction ( read add.1 ) on previous<br /><br />absolute memory address.<br /><br />f`i` holds f[(i << 2) .. ((i+1) << 2)] \| i ∈ [0..128)<br /><br />g`i` holds g[(i << 2) .. ((i+1) << 2)] \| i ∈ [0..128)<br /><br />h`i` holds h[(i << 2) .. ((i+1) << 2)] \| i ∈ [0..128)<br /><br />k`i` holds k[(i << 2) .. ((i+1) << 2)] \| i ∈ [0..128)<br /><br />Expected stack state :<br /><br />[f_start_addr, g_start_addr, h_start_addr, k_start_addr, ...]<br /><br />After execution of verification routine, stack looks like<br /><br />[ ... ]<br /><br />If verification fails, program panics, due to failure in assertion !<br /><br />Note, input memory addresses are considered to be immutable. |
