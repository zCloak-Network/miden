
## std::math::u64
| Procedure | Description |
| ----------- | ------------- |
| overflowing_add | Performs addition of two unsigned 64 bit integers preserving the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [overflowing_flag, c_hi, c_lo, ...], where c = (a + b) % 2^64 |
| wrapping_add | Performs addition of two unsigned 64 bit integers discarding the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a + b) % 2^64 |
| checked_add | Performs addition of two unsigned 64 bit integers, fails when overflowing.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a + b) % 2^64 |
| wrapping_sub | Performs subtraction of two unsigned 64 bit integers discarding the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a - b) % 2^64 |
| checked_sub | Performs subtraction of two unsigned 64 bit integers, fails when underflowing.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a - b) % 2^64 |
| overflowing_sub | Performs subtraction of two unsigned 64 bit integers preserving the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [underflowing_flag, c_hi, c_lo, ...], where c = (a - b) % 2^64 |
| wrapping_mul | Performs multiplication of two unsigned 64 bit integers discarding the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a * b) % 2^64 |
| overflowing_mul | Performs multiplication of two unsigned 64 bit integers preserving the overflow.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_mid_hi, c_mid_lo, c_lo, ...], where c = (a * b) % 2^64<br /><br />This takes 18 cycles. |
| checked_mul | Performs multiplication of two unsigned 64 bit integers, fails when overflowing.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = (a * b) % 2^64 |
| unchecked_lt | Performs less-than comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise. |
| checked_lt | Performs less-than comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a < b, and 0 otherwise. |
| unchecked_gt | Performs greater-than comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise.<br /><br />This takes 11 cycles. |
| checked_gt | Performs greater-than comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a > b, and 0 otherwise. |
| unchecked_lte | Performs less-than-or-equal comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise. |
| checked_lte | Performs less-than-or-equal comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a <= b, and 0 otherwise. |
| unchecked_gte | Performs greater-than-or-equal comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise. |
| checked_gte | Performs greater-than-or-equal comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a >= b, and 0 otherwise. |
| unchecked_eq | Performs equality comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise. |
| checked_eq | Performs equality comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise. |
| unchecked_neq | Performs inequality comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a != b, and 0 otherwise. |
| checked_neq | Performs inequality comparison of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == b, and 0 otherwise. |
| unchecked_eqz | Performs comparison to zero of an unsigned 64 bit integer.<br /><br />The input value is assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise. |
| checked_eqz | Performs comparison to zero of an unsigned 64 bit integer.<br /><br />The input value is assumed to be represented using 32 bit limbs, fails if it is not.<br /><br />Stack transition looks as follows:<br /><br />[a_hi, a_lo, ...] -> [c, ...], where c = 1 when a == 0, and 0 otherwise. |
| unchecked_min | Compares two unsigned 64 bit integers and drop the larger one from the stack.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a when a < b, and b otherwise. |
| checked_min | Compares two unsigned 64 bit integers and drop the larger one from the stack.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a when a < b, and b otherwise. |
| unchecked_max | Compares two unsigned 64 bit integers and drop the smaller one from the stack.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a when a > b, and b otherwise. |
| checked_max | Compares two unsigned 64 bit integers and drop the smaller one from the stack.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a when a > b, and b otherwise. |
| unchecked_div | Performs division of two unsigned 64 bit integers discarding the remainder.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a // b |
| checked_div | Performs division of two unsigned 64 bit integers discarding the remainder.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a // b |
| unchecked_mod | Performs modulo operation of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a % b |
| checked_mod | Performs modulo operation of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a % b |
| unchecked_divmod | Performs divmod operation of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [r_hi, r_lo, q_hi, q_lo ...], where r = a % b, q = a / b |
| checked_divmod | Performs divmod operation of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [r_hi, r_lo, q_hi, q_lo ...], where r = a % b, q = a / b |
| checked_and | Performs bitwise AND of two unsigned 64-bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, but this is not checked.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a AND b. |
| checked_or | Performs bitwise OR of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a OR b. |
| checked_xor | Performs bitwise XOR of two unsigned 64 bit integers.<br /><br />The input values are assumed to be represented using 32 bit limbs, fails if they are not.<br /><br />Stack transition looks as follows:<br /><br />[b_hi, b_lo, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a XOR b. |
| unchecked_shl | Performs left shift of one unsigned 64-bit integer using the pow2 operation.<br /><br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br /><br />The shift value should be in the range [0, 64), otherwise it will result in an<br /><br />error.<br /><br />Stack transition looks as follows:<br /><br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a << b mod 2^64.<br /><br />This takes 28 cycles. |
| unchecked_shr | Performs right shift of one unsigned 64-bit integer using the pow2 operation.<br /><br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br /><br />The shift value should be in the range [0, 64), otherwise it will result in an<br /><br />error.<br /><br />Stack transition looks as follows:<br /><br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a >> b.<br /><br />This takes 44 cycles. |
| overflowing_shl | Performs left shift of one unsigned 64-bit integer preserving the overflow and<br /><br />using the pow2 operation.<br /><br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br /><br />The shift value should be in the range [0, 64), otherwise it will result in an<br /><br />error.<br /><br />Stack transition looks as follows:<br /><br />[b, a_hi, a_lo, ...] -> [d_hi, d_lo, c_hi, c_lo, ...], where (d,c) = a << b,<br /><br />which d contains the bits shifted out.<br /><br />This takes 35 cycles. |
| overflowing_shr | Performs right shift of one unsigned 64-bit integer preserving the overflow and<br /><br />using the pow2 operation.<br /><br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br /><br />The shift value should be in the range [0, 64), otherwise it will result in an<br /><br />error.<br /><br />Stack transition looks as follows:<br /><br />[b, a_hi, a_lo, ...] -> [d_hi, d_lo, c_hi, c_lo, ...], where c = a >> b, d = a << (64 - b).<br /><br />This takes 94 cycles. |
| unchecked_rotl | Performs left rotation of one unsigned 64-bit integer using the pow2 operation.<br /><br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br /><br />The shift value should be in the range [0, 64), otherwise it will result in an<br /><br />error.<br /><br />Stack transition looks as follows:<br /><br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a << b mod 2^64.<br /><br />This takes 35 cycles. |
| unchecked_rotr | Performs right rotation of one unsigned 64-bit integer using the pow2 operation.<br /><br />The input value to be shifted is assumed to be represented using 32 bit limbs.<br /><br />The shift value should be in the range [0, 64), otherwise it will result in an<br /><br />error.<br /><br />Stack transition looks as follows:<br /><br />[b, a_hi, a_lo, ...] -> [c_hi, c_lo, ...], where c = a << b mod 2^64.<br /><br />This takes 40 cycles. |
